<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="light">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Machine Learning–Based Diabetes Risk Prediction: Evidence from BRFSS Data | Gavin&#39;s Website</title>
<meta name="keywords" content="">
<meta name="description" content="Hand-built machine learning models for diabetes risk prediction using questionnaire-derived features and basic health indicators, with recall-oriented evaluation for early screening.">
<meta name="author" content="Gavin Chen">
<link rel="canonical" href="https://lun421.github.io/projects/diabetes-risk-prediction-ml/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8a2152e90cbade3bea4a10928ac46c68be620a06d93818bc026e74d2557bb851.css" integrity="sha256-iiFS6Qy63jvqShCSisRsaL5iCgbZOBi8Am500lV7uFE=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://lun421.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://lun421.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lun421.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://lun421.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://lun421.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://lun421.github.io/projects/diabetes-risk-prediction-ml/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    }

</script>
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
      processEscapes: true
    },
    options: {
      skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  };
</script>
<script defer src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js"></script>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" referrerpolicy="no-referrer">
<meta property="og:url" content="https://lun421.github.io/projects/diabetes-risk-prediction-ml/">
  <meta property="og:site_name" content="Gavin&#39;s Website">
  <meta property="og:title" content="Machine Learning–Based Diabetes Risk Prediction: Evidence from BRFSS Data">
  <meta property="og:description" content="Hand-built machine learning models for diabetes risk prediction using questionnaire-derived features and basic health indicators, with recall-oriented evaluation for early screening.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="projects">
    <meta property="article:published_time" content="2025-06-01T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-06-01T00:00:00+00:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Machine Learning–Based Diabetes Risk Prediction: Evidence from BRFSS Data">
<meta name="twitter:description" content="Hand-built machine learning models for diabetes risk prediction using questionnaire-derived features and basic health indicators, with recall-oriented evaluation for early screening.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Projects",
      "item": "https://lun421.github.io/projects/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Machine Learning–Based Diabetes Risk Prediction: Evidence from BRFSS Data",
      "item": "https://lun421.github.io/projects/diabetes-risk-prediction-ml/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Machine Learning–Based Diabetes Risk Prediction: Evidence from BRFSS Data",
  "name": "Machine Learning–Based Diabetes Risk Prediction: Evidence from BRFSS Data",
  "description": "Hand-built machine learning models for diabetes risk prediction using questionnaire-derived features and basic health indicators, with recall-oriented evaluation for early screening.",
  "keywords": [
    
  ],
  "articleBody": "Introduction Diabetes is a common chronic metabolic disease whose early-stage symptoms are often subtle, yet it can lead to severe complications if left untreated. Early detection and timely intervention not only help improve individual quality of life but also effectively reduce overall healthcare expenditures and resource burdens. Current diagnostic practices primarily rely on fasting blood glucose and glycated hemoglobin (HbA1c) tests. However, these blood-based examinations present practical challenges in terms of cost, convenience, and accessibility, particularly in resource-limited settings.\nTherefore, developing diabetes risk prediction models based on simple, non-invasive health indicators or questionnaire-based data holds substantial value for public health screening and policy applications. This study aims to construct machine learning–based risk prediction models to support early screening and informed health decision-making.\nThe dataset used in this study is obtained from the U.S. Centers for Disease Control and Prevention (CDC), specifically from the 2015 Behavioral Risk Factor Surveillance System (BRFSS). The BRFSS is a nationwide telephone survey that collects adult health-related information across the United States. The dataset consists of 253,680 observations and 22 variables, covering individual health conditions, lifestyle behaviors, and socioeconomic characteristics.\nThe target variable is a binary indicator, denoted as Diabetes_binary, which represents whether an individual has been diagnosed with diabetes by a physician and is formulated as a binary classification problem. Among the 22 variables, 14 are binary features (e.g., HighBP, Smoker, PhysActivity), while the remaining variables are continuous in nature (e.g., BMI and Age.)\nThis study focuses on exploring the applicability of machine learning methods in the public health domain and aims to develop a diabetes risk self-assessment model that can be utilized by the general population, thereby increasing the likelihood of early detection and intervention.\nMethodology Data Preprocessing The dataset contains no missing values. Although duplicate observations may exist due to individuals sharing identical characteristics such as age and health status, these records correspond to different individuals and are therefore retained.\nExploratory data analysis (EDA) indicates that no pairwise correlation between features exceeds $0.6$. Given that the dataset consists primarily of categorical variables and exhibits limited feature complexity, all available variables are retained as model features.\nTo improve model performance and stability, a series of data preprocessing procedures is conducted prior to model training. First, stratified sampling is applied based on the binary diabetes target variable to preserve class proportions. The dataset is split into a training set 60%, a validation set 20%, and a test set 20%.\nFeature standardization is then performed. As the dataset contains both binary categorical variables and continuous numerical variables, standardization is applied only to numerical features, while categorical variables are left unchanged. Numerical features are transformed using $Z$-score normalization, where the mean and standard deviation are computed from the training set. Each numerical feature is scaled to follow a distribution with mean 0 and standard deviation 1, and the same scaling parameters are subsequently applied to the validation and test sets to prevent data leakage.\nModel Descriptions 1. Least Squares Method This study first applies the Ordinary Least Squares (OLS) method to construct a linear model for estimating an individual’s probability of developing diabetes, which is subsequently used for classification. Model parameters are obtained by solving the closed-form solution using the training data, given by:\n$$ \\begin{aligned} \\hat{\\boldsymbol{\\theta}} \u0026= \\left( \\mathbf{X}^\\top \\mathbf{X} \\right)^{-1} \\mathbf{X}^\\top \\mathbf{y} \\end{aligned} $$\nwhere $\\mathbf{X}$ denotes the standardized feature matrix and $\\mathbf{y}$ represents the corresponding target variable. The model produces a continuous output score, which reflects the individual’s degree of inclination toward the positive class ($y = 1$, indicating the presence of diabetes). To enhance the model’s ability to identify individuals at high risk of diabetes, this study places particular emphasis on recall as the primary evaluation criterion. In public health applications, failing to identify high-risk individuals (i.e., false negatives) may delay timely medical intervention and lead to increased healthcare and societal costs. Consequently, improving recall is considered more critical than minimizing false positives in this context.\nAccordingly, we adopt the $F_\\beta$-score as the basis for classification threshold selection, setting $\\beta = 2$ to assign greater weight to recall while still accounting for precision. The $F_\\beta$-score is defined as:\n$$ \\begin{aligned} \\text{Precision} \u0026= \\frac{TP}{TP + FP} \\end{aligned} $$\n$$ \\begin{aligned} \\text{Recall} \u0026= \\frac{TP}{TP + FN} \\end{aligned} $$\n$$ \\begin{aligned} F_\\beta \u0026= (1 + \\beta^2)\\cdot \\frac{\\text{Precision} \\cdot \\text{Recall}} {\\beta^2 \\cdot \\text{Precision} + \\text{Recall}} \\end{aligned} $$\nUsing the validation set, we evaluate model performance across different classification thresholds and select the threshold that maximizes the $F_2$-score. This optimal threshold is then applied to the test set to conduct final performance evaluation and confusion matrix analysis.\n2. Naïve Bayes Classifier As the second predictive model constructed in this study, we implement a Naïve Bayes classifier to model diabetes risk within a probabilistic inference framework. The task is formulated as a binary classification problem, and different likelihood functions are specified according to the data type of each feature.\nThe Naïve Bayes model is based on the conditional independence assumption, which assumes that features are independent given the class label $y$. Under this assumption, the joint probability of an observation $x$ belonging to class $y$ can be factorized and used for classification via maximum a posteriori (MAP) estimation, defined as:\n$$ \\begin{aligned} \\hat{y} = \\arg\\max_{y} P(y \\mid x) = \\arg\\max_{y} \\frac{P(x \\mid y)P(y)}{P(x)} \\propto P(x \\mid y)\\cdot P(y) \\end{aligned} $$\nHere, $P(y)$ denotes the prior probability of class $y$, and $P(x \\mid y)$ represents the class-conditional likelihood of the observed features $x$. Since $P(x)$ is constant across all classes, it can be omitted during optimization.\nTo accommodate both continuous and binary predictors, the likelihood function is specified separately according to feature type.\n(i.) Continuous Features (Gaussian Distribution) For numerical features, we assume that each feature $x_i$ follows a normal (Gaussian) distribution conditioned on the class label $y$. The likelihood function is given by:\n$$ \\begin{aligned} P(x_i \\mid y) \u0026= \\frac{1}{\\sqrt{2\\pi\\sigma_{iy}^2}} \\exp\\left( -\\frac{(x_i - \\mu_{iy})^2}{2\\sigma_{iy}^2} \\right) \\end{aligned} $$\nwhere $\\mu_{iy}$ and $\\sigma_{iy}^2$ denote the class-specific mean and variance of feature $x_i$, respectively.\n(ii.) Binary Features (Bernoulli Distribution) For binary features, a Bernoulli distribution is employed. The likelihood is defined as:\n$$ \\begin{aligned} P(x_j \\mid y) \u0026= p_{jy}^{x_j} (1 - p_{jy})^{1 - x_j} \\end{aligned} $$ where $p_{jy}$ represents the probability that feature $x_j = 1$ under class $y$.\nTo avoid numerical underflow, the log-likelihood is computed by summing over all features:\n$$ \\begin{aligned} \\log P(\\mathbf{x} \\mid y) = \\sum_{i \\in \\text{numeric}} \\log P(x_i \\mid y) + \\sum_{j \\in \\text{binary}} \\log P(x_j \\mid y) \\end{aligned} $$\nThe final discriminant function combines the log-likelihood with the log prior: $$ \\begin{aligned} \\hat{y} = \\arg\\max_{y} \\left[ \\log P(y) + \\log P(\\mathbf{x} \\mid y) \\right] \\end{aligned} $$\nConsistent with the procedure adopted for the linear models, we further adjust the classification threshold on the posterior probability output by the Naïve Bayes classifier. The optimal threshold is selected using the validation set to maximize the $F_2$-score, placing greater emphasis on recall. During inference, the model outputs the estimated probability $P(y=1 \\mid x)$, and classification is performed based on the selected optimal cutoff.\n3. Logistic Regression with Gradient Descent This study further implements a logistic regression model optimized via gradient descent, serving as a probabilistic classification method with strong interpretability and generalization capability. The model is trained by minimizing the binary cross-entropy loss, which is equivalent to the negative log-likelihood function, defined as:\n$$ \\begin{aligned} \\mathcal{L}(w, b) \u0026= -\\frac{1}{n} \\sum_{i=1}^{n} \\Big[y_i \\log(\\hat{p}_i)+ (1 - y_i)\\log(1 - \\hat{p}_i) \\Big] ,\\ \\hat{p}_i = \\sigma\\left( x_i^\\top w + b \\right) \\end{aligned} $$\nwhere $w$ denotes the weight vector, $b$ is the bias term, and $\\hat{p}_i$ represents the predicted probability that observation $i$ belongs to the positive class.\nThe function $\\sigma(\\cdot)$ denotes the sigmoid activation function, which maps a linear combination of features to a probability:\n$$ \\begin{aligned} \\sigma(z) = \\frac{1}{1 + e^{-z}} \\end{aligned} $$\nModel parameters are updated using batch gradient descent, where both $w$ and $b$ are iteratively optimized. Based on empirical tuning, the learning rate is set to 0.01, and the maximum number of training iterations is capped at 10,000.\nTo prevent overfitting and improve training efficiency, an early stopping mechanism is employed during model training. Training is terminated if the change in validation loss remains below 0.0001 for 100 consecutive epochs, indicating convergence. The parameter set that achieves the lowest validation loss is retained. Throughout training, loss values are recorded, and both training and validation loss curves are plotted to assess convergence behavior and potential overfitting.\nDuring the evaluation stage, the model outputs a predicted probability $\\hat{p}_i = P(y_i = 1 \\mid x_i)$ for each observation. Using the validation set, different classification thresholds are examined to identify the optimal cutoff.\nConsistent with the evaluation strategy adopted for other models, the $F_2$-score is used as the primary performance metric. The classification threshold is selected to maximize the $F_2$-score, thereby emphasizing recall in scenarios where identifying high-risk individuals is of greater importance than minimizing false positives.\n4. Re-modeling with Undersampling To examine the impact of class imbalance on model performance, we design an alternative training pipeline based on random undersampling. Specifically, both the training set and the validation set are independently undersampled at a ratio of 1:1, where negative-class observations are randomly retained to match the number of positive-class samples, resulting in balanced datasets.\nFollowing undersampling, feature standardization is performed using $Z$-score normalization. The standardization procedure remains identical to that used in the original pipeline, with scaling parameters estimated from the undersampled training set and subsequently applied to the validation and test sets.\nAfter undersampling, the logistic regression model is retrained using the balanced data. The same threshold search and performance evaluation procedures described previously are repeated to ensure a fair comparison. This setup allows us to explicitly assess how class balancing affects recall and precision under identical model specifications.\nFinally, model performance is compared between the undersampled and non-undersampled settings on the test set. The comparison focuses on the $F_2$-score and the confusion matrix, providing practical insights into trade-offs between sensitivity and specificity under different class distribution assumptions.\n5. Other Methods To further enhance model performance and interpretability, this study also explored alternative data preprocessing and dimensionality reduction techniques, including principal component analysis (PCA) and linear discriminant analysis (LDA). These methods were considered with the objective of simplifying the feature space and reducing model complexity.\nHowever, in the present dataset, the original variables exhibit sufficient discriminative power. Empirical results indicate that dimensionality reduction leads to partial information loss, which in turn degrades classification performance. Consequently, PCA and LDA are not incorporated into the primary analytical pipeline.\nIn addition, a linear regression model optimized via Gradient Descent was also implemented as a binary classification approach. Nevertheless, its predictive performance was consistently inferior to that of logistic regression, and therefore it was not retained as a principal linear model in the final analysis.\nOverall, model selection in this study prioritizes predictive performance, interpretability, and training stability. After evaluating multiple modeling strategies, three approaches demonstrating the most stable performance and the greatest applicability to public health contexts are retained for in-depth discussion.\nResults and Discussion Metric Least Square Naïve Bayes Logistic GD Undersample Logistic GD TN 27,844 25,230 28,918 16,686 FP 15,824 18,438 14,748 26,982 TP 5,965 6,119 5,783 6,814 FN 1,105 951 1,286 256 Precision 0.274 0.249 0.282 0.202 Recall 0.844 0.865 0.818 0.964 $F_2$ score 0.596 0.579 0.593 0.549 Table above summarizes the predictive performance of each model on the test set, allowing for a detailed comparison of trade-offs among precision, recall, and the $F_2$-score.\nFirst, although the Least Squares model is inherently a regression-based approach, its predictions can be converted into a classification output through threshold adjustment. As a result, the model demonstrates meaningful performance in the classification task. On the test set, it achieves a recall of 0.844, indicating effective identification of most individuals with diabetes. At the same time, its precision is 0.274, and it attains the highest $F_2$-score among all models at 0.596. Despite its relatively simple predictive structure, the Least Squares model achieves a favorable balance between recall and precision, making it well suited for early-stage screening applications.\nNext, the Naïve Bayes model, which assumes conditional independence among features and accommodates both continuous and binary variables, achieves the highest recall of all models at 0.865. This result highlights its strong tendency to identify positive (diabetes) cases. However, its precision is only 0.249, reflecting a substantial number of false positives, with a total of 18,438 false positive predictions. This behavior suggests that the model is prone to overpredicting the positive class, potentially leading to unnecessary medical examinations and increased healthcare costs. Its overall $F_2$-score is 0.579, lower than that of the Least Squares and logistic gradient descent models, indicating a trade-off incurred by prioritizing recall.\nThe logistic regression model trained via gradient descent achieves a precision of 0.282 and a recall of 0.818 on the test set, representing the highest precision among the four models. Although its recall ranks third, the model maintains a relatively stable balance between precision and recall, resulting in an $F_2$-score of 0.593. This performance suggests that logistic regression offers a robust compromise between false positives and false negatives, making it suitable for applications where both misdiagnosis and missed diagnosis risks must be considered. The model also demonstrates strong generalization capability.\nFinally, the undersampled logistic regression model, in which the class ratio in the training and validation sets is adjusted to 1:1, achieves a substantial increase in recall to 0.964, successfully identifying nearly all individuals with diabetes, with only 256 false negatives remaining. This result demonstrates exceptional sensitivity to the positive class. However, this improvement comes at the cost of extreme bias toward positive predictions, resulting in 26,982 false positives and a corresponding drop in precision to 0.202, the lowest among all models. Consequently, the overall $F_2$-score decreases to 0.549, reflecting the significant trade-off required to achieve such a high recall.\nOverall, when the application context prioritizes initial screening, where recall and the $F_2$-score are the primary evaluation criteria, the Least Squares and logistic regression models provide the most balanced performance, effectively managing the trade-off between detection capability and misclassification risk. If the primary objective is to minimize missed diagnoses, the undersampled logistic regression model remains clinically meaningful despite its high false positive rate. Conversely, in scenarios where precise prediction and the avoidance of unnecessary medical interventions are emphasized, further threshold calibration or complementary strategies—such as probability calibration or multi-stage screening designs—may be required to achieve a more desirable balance.\nConclusion This study successfully constructs diabetes risk prediction models using multiple machine learning approaches, demonstrating the feasibility of identifying high-risk individuals based solely on simple questionnaire data and basic health indicators. Without relying on costly and invasive procedures such as blood tests, the proposed models exhibit strong predictive performance, particularly in terms of $Recall$ and the $F_2$-score, highlighting their potential for early screening and public health applications.\nIn terms of model performance, the Least Squares and logistic regression (gradient descent) models achieve a favorable balance between recall and the $F_2$-score, making them well suited for large-scale preliminary screening. The Naïve Bayes model attains the highest recall but suffers from an elevated risk of false positives, while the undersampled logistic regression model, although capable of identifying nearly all high-risk individuals, incurs a substantial loss in precision. These trade-offs reflect a fundamental consideration in public health decision-making: balancing the risks of misclassification against the consequences of missed diagnoses. Different modeling strategies thus correspond to distinct policy priorities regarding sensitivity and specificity.\nOverall, this study demonstrates the practicality of questionnaire-based diabetes risk prediction and achieves strong classification performance under a recall-oriented evaluation framework. Future research may incorporate non-parametric machine learning methods to relax distributional assumptions inherent in traditional models, thereby enhancing model flexibility and accuracy in the presence of complex feature interactions and nonlinear relationships.\nIn summary, this research highlights the significant potential of low-cost and highly accessible predictive models in disease prevention. Such models may be deployed in mobile self-assessment tools, community-based preliminary screening programs, and policy-level risk evaluation frameworks, complementing existing healthcare systems and advancing the core principles of preventive medicine.\n",
  "wordCount" : "2668",
  "inLanguage": "en",
  "datePublished": "2025-06-01T00:00:00Z",
  "dateModified": "2025-06-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Gavin Chen"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://lun421.github.io/projects/diabetes-risk-prediction-ml/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Gavin's Website",
    "logo": {
      "@type": "ImageObject",
      "url": "https://lun421.github.io/favicon.ico"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://lun421.github.io/" accesskey="h" title="Gavin&#39;s Website (Alt + H)">Gavin&#39;s Website</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://lun421.github.io/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://lun421.github.io/profile/" title="Profile">
                    <span>Profile</span>
                </a>
            </li>
            <li>
                <a href="https://lun421.github.io/projects/" title="Project">
                    <span>Project</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Machine Learning–Based Diabetes Risk Prediction: Evidence from BRFSS Data
    </h1>
    <div class="post-meta"><span title='2025-06-01 00:00:00 +0000 UTC'>June 1, 2025</span>&nbsp;·&nbsp;<span>13 min</span>&nbsp;·&nbsp;<span>Gavin Chen</span>

</div>
  </header> 
  <div class="post-content"><h1 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h1>
<p>Diabetes is a common chronic metabolic disease whose early-stage symptoms are often subtle, yet it can lead to severe complications if left untreated. Early detection and timely intervention not only help improve individual quality of life but also effectively reduce overall healthcare expenditures and resource burdens. Current diagnostic practices primarily rely on fasting blood glucose and glycated hemoglobin (HbA1c) tests. However, these blood-based examinations present practical challenges in terms of cost, convenience, and accessibility, particularly in resource-limited settings.</p>
<p>Therefore, developing diabetes risk prediction models based on simple, non-invasive health indicators or questionnaire-based data holds substantial value for public health screening and policy applications. This study aims to construct machine learning–based risk prediction models to support early screening and informed health decision-making.</p>
<p>The dataset used in this study is obtained from the U.S. Centers for Disease Control and Prevention (CDC), specifically from the 2015 Behavioral Risk Factor Surveillance System (BRFSS). The BRFSS is a nationwide telephone survey that collects adult health-related information across the United States. The dataset consists of 253,680 observations and 22 variables, covering individual health conditions, lifestyle behaviors, and socioeconomic characteristics.</p>
<p>The target variable is a binary indicator, denoted as Diabetes_binary, which represents whether an individual has been diagnosed with diabetes by a physician and is formulated as a binary classification problem. Among the 22 variables, 14 are binary features (e.g., HighBP, Smoker, PhysActivity), while the remaining variables are continuous in nature (e.g., BMI and Age.)</p>
<p>This study focuses on exploring the applicability of machine learning methods in the public health domain and aims to develop a diabetes risk self-assessment model that can be utilized by the general population, thereby increasing the likelihood of early detection and intervention.</p>
<h1 id="methodology">Methodology<a hidden class="anchor" aria-hidden="true" href="#methodology">#</a></h1>
<h2 id="data-preprocessing">Data Preprocessing<a hidden class="anchor" aria-hidden="true" href="#data-preprocessing">#</a></h2>
<p>The dataset contains no missing values. Although duplicate observations may exist due to individuals sharing identical characteristics such as age and health status, these records correspond to different individuals and are therefore retained.</p>
<p>Exploratory data analysis (EDA) indicates that no pairwise correlation between features exceeds $0.6$. Given that the dataset consists primarily of categorical variables and exhibits limited feature complexity, all available variables are retained as model features.</p>
<p><img alt="heatmap" loading="lazy" src="/projects/diabetes-risk-prediction-ml/heatmap.png"></p>
<p>To improve model performance and stability, a series of data preprocessing procedures is conducted prior to model training. First, stratified sampling is applied based on the binary diabetes target variable to preserve class proportions. The dataset is split into a training set 60%, a validation set 20%, and a test set 20%.</p>
<p>Feature standardization is then performed. As the dataset contains both binary categorical variables and continuous numerical variables, standardization is applied only to numerical features, while categorical variables are left unchanged. Numerical features are transformed using $Z$-score normalization, where the mean and standard deviation are computed from the training set. Each numerical feature is scaled to follow a distribution with mean 0 and standard deviation 1, and the same scaling parameters are subsequently applied to the validation and test sets to prevent data leakage.</p>
<h2 id="model-descriptions">Model Descriptions<a hidden class="anchor" aria-hidden="true" href="#model-descriptions">#</a></h2>
<h3 id="1-least-squares-method">1. Least Squares Method<a hidden class="anchor" aria-hidden="true" href="#1-least-squares-method">#</a></h3>
<p>This study first applies the Ordinary Least Squares (OLS) method to construct a linear model for estimating an individual’s probability of developing diabetes, which is subsequently used for classification. Model parameters are obtained by solving the closed-form solution using the training data, given by:</p>
<p>$$
\begin{aligned}
\hat{\boldsymbol{\theta}}
&amp;= \left( \mathbf{X}^\top \mathbf{X} \right)^{-1} \mathbf{X}^\top \mathbf{y}
\end{aligned}
$$</p>
<p>where $\mathbf{X}$ denotes the standardized feature matrix and $\mathbf{y}$ represents the corresponding target variable. The model produces a continuous output score, which reflects the individual’s degree of inclination toward the positive class ($y = 1$, indicating the presence of diabetes).
To enhance the model’s ability to identify individuals at high risk of diabetes, this study places particular emphasis on recall as the primary evaluation criterion. In public health applications, failing to identify high-risk individuals (i.e., false negatives) may delay timely medical intervention and lead to increased healthcare and societal costs. Consequently, improving recall is considered more critical than minimizing false positives in this context.</p>
<p>Accordingly, we adopt the $F_\beta$-score as the basis for classification threshold selection, setting $\beta = 2$ to assign greater weight to recall while still accounting for precision. The $F_\beta$-score is defined as:</p>
<p>$$
\begin{aligned}
\text{Precision}
&amp;= \frac{TP}{TP + FP}
\end{aligned}
$$</p>
<p>$$
\begin{aligned}
\text{Recall}
&amp;= \frac{TP}{TP + FN}
\end{aligned}
$$</p>
<p>$$
\begin{aligned}
F_\beta
&amp;= (1 + \beta^2)\cdot
\frac{\text{Precision} \cdot \text{Recall}}
{\beta^2 \cdot \text{Precision} + \text{Recall}}
\end{aligned}
$$</p>
<p>Using the validation set, we evaluate model performance across different classification thresholds and select the threshold that maximizes the $F_2$-score. This optimal threshold is then applied to the test set to conduct final performance evaluation and confusion matrix analysis.</p>
<p><img alt="leastsquare" loading="lazy" src="/projects/diabetes-risk-prediction-ml/leastsquareplot.png"></p>
<h3 id="2-naïve-bayes-classifier">2. Naïve Bayes Classifier<a hidden class="anchor" aria-hidden="true" href="#2-naïve-bayes-classifier">#</a></h3>
<p>As the second predictive model constructed in this study, we implement a Naïve Bayes classifier to model diabetes risk within a probabilistic inference framework. The task is formulated as a binary classification problem, and different likelihood functions are specified according to the data type of each feature.</p>
<p>The Naïve Bayes model is based on the conditional independence assumption, which assumes that features are independent given the class label $y$. Under this assumption, the joint probability of an observation $x$ belonging to class $y$ can be factorized and used for classification via maximum a posteriori (MAP) estimation, defined as:</p>
<p>$$
\begin{aligned}
\hat{y} = \arg\max_{y} P(y \mid x)
= \arg\max_{y} \frac{P(x \mid y)P(y)}{P(x)}
\propto P(x \mid y)\cdot P(y)
\end{aligned}
$$</p>
<p>Here, $P(y)$ denotes the prior probability of class $y$, and $P(x \mid y)$ represents the class-conditional likelihood of the observed features $x$. Since $P(x)$ is constant across all classes, it can be omitted during optimization.</p>
<p>To accommodate both continuous and binary predictors, the likelihood function is specified separately according to feature type.</p>
<br>
<h4 id="i-continuous-features-gaussian-distribution">(i.) Continuous Features (Gaussian Distribution)<a hidden class="anchor" aria-hidden="true" href="#i-continuous-features-gaussian-distribution">#</a></h4>
<p>For numerical features, we assume that each feature $x_i$ follows a normal (Gaussian) distribution conditioned on the class label $y$. The likelihood function is given by:</p>
<p>$$
\begin{aligned}
P(x_i \mid y)
&amp;= \frac{1}{\sqrt{2\pi\sigma_{iy}^2}}
\exp\left(
-\frac{(x_i - \mu_{iy})^2}{2\sigma_{iy}^2}
\right)
\end{aligned}
$$</p>
<p>where $\mu_{iy}$ and $\sigma_{iy}^2$ denote the class-specific mean and variance of feature $x_i$, respectively.</p>
<br>
<h4 id="ii-binary-features-bernoulli-distribution">(ii.) Binary Features (Bernoulli Distribution)<a hidden class="anchor" aria-hidden="true" href="#ii-binary-features-bernoulli-distribution">#</a></h4>
<p>For binary features, a Bernoulli distribution is employed. The likelihood is defined as:</p>
<p>$$
\begin{aligned}
P(x_j \mid y)
&amp;= p_{jy}^{x_j}
(1 - p_{jy})^{1 - x_j}
\end{aligned}
$$
where $p_{jy}$ represents the probability that feature $x_j = 1$ under class $y$.</p>
<p>To avoid numerical underflow, the log-likelihood is computed by summing over all features:</p>
<p>$$
\begin{aligned}
\log P(\mathbf{x} \mid y) = \sum_{i \in \text{numeric}} \log P(x_i \mid y) + \sum_{j \in \text{binary}} \log P(x_j \mid y)
\end{aligned}
$$</p>
<p>The final discriminant function combines the log-likelihood with the log prior:
$$
\begin{aligned}
\hat{y} = \arg\max_{y} \left[ \log P(y) + \log P(\mathbf{x} \mid y) \right]
\end{aligned}
$$</p>
<p>Consistent with the procedure adopted for the linear models, we further adjust the classification threshold on the posterior probability output by the Naïve Bayes classifier. The optimal threshold is selected using the validation set to maximize the $F_2$-score, placing greater emphasis on recall. During inference, the model outputs the estimated probability $P(y=1 \mid x)$, and classification is performed based on the selected optimal cutoff.</p>
<p><img alt="NBplot" loading="lazy" src="/projects/diabetes-risk-prediction-ml/NBplot.png"></p>
<h3 id="3-logistic-regression-with-gradient-descent">3. Logistic Regression with Gradient Descent<a hidden class="anchor" aria-hidden="true" href="#3-logistic-regression-with-gradient-descent">#</a></h3>
<p>This study further implements a logistic regression model optimized via gradient descent, serving as a probabilistic classification method with strong interpretability and generalization capability. The model is trained by minimizing the binary cross-entropy loss, which is equivalent to the negative log-likelihood function, defined as:</p>
<p>$$
\begin{aligned}
\mathcal{L}(w, b)
&amp;= -\frac{1}{n}
\sum_{i=1}^{n}
\Big[y_i \log(\hat{p}_i)+ (1 - y_i)\log(1 - \hat{p}_i)
\Big] ,\
\hat{p}_i = \sigma\left( x_i^\top w + b \right)
\end{aligned}
$$</p>
<p>where $w$ denotes the weight vector, $b$ is the bias term, and $\hat{p}_i$ represents the predicted probability that observation $i$ belongs to the positive class.</p>
<p>The function $\sigma(\cdot)$ denotes the sigmoid activation function, which maps a linear combination of features to a probability:</p>
<p>$$
\begin{aligned}
\sigma(z) = \frac{1}{1 + e^{-z}}
\end{aligned}
$$</p>
<p>Model parameters are updated using batch gradient descent, where both $w$ and $b$ are iteratively optimized. Based on empirical tuning, the learning rate is set to 0.01, and the maximum number of training iterations is capped at 10,000.</p>
<p>To prevent overfitting and improve training efficiency, an early stopping mechanism is employed during model training. Training is terminated if the change in validation loss remains below 0.0001 for 100 consecutive epochs, indicating convergence. The parameter set that achieves the lowest validation loss is retained. Throughout training, loss values are recorded, and both training and validation loss curves are plotted to assess convergence behavior and potential overfitting.</p>
<p><img alt="losscurve" loading="lazy" src="/projects/diabetes-risk-prediction-ml/losscurve.png"></p>
<p>During the evaluation stage, the model outputs a predicted probability $\hat{p}_i = P(y_i = 1 \mid x_i)$ for each observation. Using the validation set, different classification thresholds are examined to identify the optimal cutoff.</p>
<p>Consistent with the evaluation strategy adopted for other models, the $F_2$-score is used as the primary performance metric. The classification threshold is selected to maximize the $F_2$-score, thereby emphasizing recall in scenarios where identifying high-risk individuals is of greater importance than minimizing false positives.</p>
<p><img alt="logisticGD" loading="lazy" src="/projects/diabetes-risk-prediction-ml/logisticGDplot.png"></p>
<h3 id="4-re-modeling-with-undersampling">4. Re-modeling with Undersampling<a hidden class="anchor" aria-hidden="true" href="#4-re-modeling-with-undersampling">#</a></h3>
<p>To examine the impact of class imbalance on model performance, we design an alternative training pipeline based on random undersampling. Specifically, both the training set and the validation set are independently undersampled at a ratio of 1:1, where negative-class observations are randomly retained to match the number of positive-class samples, resulting in balanced datasets.</p>
<br>
<p><img alt="piechart" loading="lazy" src="/projects/diabetes-risk-prediction-ml/pie.png"></p>
<p>Following undersampling, feature standardization is performed using $Z$-score normalization. The standardization procedure remains identical to that used in the original pipeline, with scaling parameters estimated from the undersampled training set and subsequently applied to the validation and test sets.</p>
<p>After undersampling, the logistic regression model is retrained using the balanced data. The same threshold search and performance evaluation procedures described previously are repeated to ensure a fair comparison. This setup allows us to explicitly assess how class balancing affects recall and precision under identical model specifications.</p>
<p>Finally, model performance is compared between the undersampled and non-undersampled settings on the test set. The comparison focuses on the $F_2$-score and the confusion matrix, providing practical insights into trade-offs between sensitivity and specificity under different class distribution assumptions.</p>
<h3 id="5-other-methods">5. Other Methods<a hidden class="anchor" aria-hidden="true" href="#5-other-methods">#</a></h3>
<p>To further enhance model performance and interpretability, this study also explored alternative data preprocessing and dimensionality reduction techniques, including principal component analysis (PCA) and linear discriminant analysis (LDA). These methods were considered with the objective of simplifying the feature space and reducing model complexity.</p>
<p>However, in the present dataset, the original variables exhibit sufficient discriminative power. Empirical results indicate that dimensionality reduction leads to partial information loss, which in turn degrades classification performance. Consequently, PCA and LDA are not incorporated into the primary analytical pipeline.</p>
<p>In addition, a linear regression model optimized via Gradient Descent was also implemented as a binary classification approach. Nevertheless, its predictive performance was consistently inferior to that of logistic regression, and therefore it was not retained as a principal linear model in the final analysis.</p>
<p>Overall, model selection in this study prioritizes predictive performance, interpretability, and training stability. After evaluating multiple modeling strategies, three approaches demonstrating the most stable performance and the greatest applicability to public health contexts are retained for in-depth discussion.</p>
<h1 id="results-and-discussion">Results and Discussion<a hidden class="anchor" aria-hidden="true" href="#results-and-discussion">#</a></h1>
<table>
  <thead>
      <tr>
          <th>Metric</th>
          <th>Least Square</th>
          <th>Naïve Bayes</th>
          <th>Logistic GD</th>
          <th>Undersample Logistic GD</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>TN</td>
          <td>27,844</td>
          <td>25,230</td>
          <td>28,918</td>
          <td>16,686</td>
      </tr>
      <tr>
          <td>FP</td>
          <td>15,824</td>
          <td>18,438</td>
          <td>14,748</td>
          <td>26,982</td>
      </tr>
      <tr>
          <td>TP</td>
          <td>5,965</td>
          <td>6,119</td>
          <td>5,783</td>
          <td>6,814</td>
      </tr>
      <tr>
          <td>FN</td>
          <td>1,105</td>
          <td>951</td>
          <td>1,286</td>
          <td>256</td>
      </tr>
      <tr>
          <td>Precision</td>
          <td>0.274</td>
          <td>0.249</td>
          <td>0.282</td>
          <td><span class="low">0.202</span></td>
      </tr>
      <tr>
          <td>Recall</td>
          <td>0.844</td>
          <td>0.865</td>
          <td><span class="mid">0.818</span></td>
          <td><span class="high">0.964</span></td>
      </tr>
      <tr>
          <td>$F_2$ score</td>
          <td><span class="best">0.596</span></td>
          <td>0.579</td>
          <td>0.593</td>
          <td>0.549</td>
      </tr>
  </tbody>
</table>
<p>Table above summarizes the predictive performance of each model on the test set, allowing for a detailed comparison of trade-offs among precision, recall, and the $F_2$-score.</p>
<p>First, although the Least Squares model is inherently a regression-based approach, its predictions can be converted into a classification output through threshold adjustment. As a result, the model demonstrates meaningful performance in the classification task. On the test set, it achieves a recall of 0.844, indicating effective identification of most individuals with diabetes. At the same time, its precision is 0.274, and it attains the highest $F_2$-score among all models at 0.596. Despite its relatively simple predictive structure, the Least Squares model achieves a favorable balance between recall and precision, making it well suited for early-stage screening applications.</p>
<p>Next, the Naïve Bayes model, which assumes conditional independence among features and accommodates both continuous and binary variables, achieves the highest recall of all models at 0.865. This result highlights its strong tendency to identify positive (diabetes) cases. However, its precision is only 0.249, reflecting a substantial number of false positives, with a total of 18,438 false positive predictions. This behavior suggests that the model is prone to overpredicting the positive class, potentially leading to unnecessary medical examinations and increased healthcare costs. Its overall $F_2$-score is 0.579, lower than that of the Least Squares and logistic gradient descent models, indicating a trade-off incurred by prioritizing recall.</p>
<p>The logistic regression model trained via gradient descent achieves a precision of 0.282 and a recall of 0.818 on the test set, representing the highest precision among the four models. Although its recall ranks third, the model maintains a relatively stable balance between precision and recall, resulting in an $F_2$-score of 0.593. This performance suggests that logistic regression offers a robust compromise between false positives and false negatives, making it suitable for applications where both misdiagnosis and missed diagnosis risks must be considered. The model also demonstrates strong generalization capability.</p>
<p>Finally, the undersampled logistic regression model, in which the class ratio in the training and validation sets is adjusted to 1:1, achieves a substantial increase in recall to 0.964, successfully identifying nearly all individuals with diabetes, with only 256 false negatives remaining. This result demonstrates exceptional sensitivity to the positive class. However, this improvement comes at the cost of extreme bias toward positive predictions, resulting in 26,982 false positives and a corresponding drop in precision to 0.202, the lowest among all models. Consequently, the overall $F_2$-score decreases to 0.549, reflecting the significant trade-off required to achieve such a high recall.</p>
<p>Overall, when the application context prioritizes initial screening, where recall and the $F_2$-score are the primary evaluation criteria, the Least Squares and logistic regression models provide the most balanced performance, effectively managing the trade-off between detection capability and misclassification risk. If the primary objective is to minimize missed diagnoses, the undersampled logistic regression model remains clinically meaningful despite its high false positive rate. Conversely, in scenarios where precise prediction and the avoidance of unnecessary medical interventions are emphasized, further threshold calibration or complementary strategies—such as probability calibration or multi-stage screening designs—may be required to achieve a more desirable balance.</p>
<h1 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h1>
<p>This study successfully constructs diabetes risk prediction models using multiple machine learning approaches, demonstrating the feasibility of identifying high-risk individuals based solely on simple questionnaire data and basic health indicators. Without relying on costly and invasive procedures such as blood tests, the proposed models exhibit strong predictive performance, particularly in terms of $Recall$ and the $F_2$-score, highlighting their potential for early screening and public health applications.</p>
<p>In terms of model performance, the Least Squares and logistic regression (gradient descent) models achieve a favorable balance between recall and the $F_2$-score, making them well suited for large-scale preliminary screening. The Naïve Bayes model attains the highest recall but suffers from an elevated risk of false positives, while the undersampled logistic regression model, although capable of identifying nearly all high-risk individuals, incurs a substantial loss in precision. These trade-offs reflect a fundamental consideration in public health decision-making: balancing the risks of misclassification against the consequences of missed diagnoses. Different modeling strategies thus correspond to distinct policy priorities regarding sensitivity and specificity.</p>
<p>Overall, this study demonstrates the practicality of questionnaire-based diabetes risk prediction and achieves strong classification performance under a recall-oriented evaluation framework. Future research may incorporate non-parametric machine learning methods to relax distributional assumptions inherent in traditional models, thereby enhancing model flexibility and accuracy in the presence of complex feature interactions and nonlinear relationships.</p>
<p>In summary, this research highlights the significant potential of low-cost and highly accessible predictive models in disease prevention. Such models may be deployed in mobile self-assessment tools, community-based preliminary screening programs, and policy-level risk evaluation frameworks, complementing existing healthcare systems and advancing the core principles of preventive medicine.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="next" href="https://lun421.github.io/projects/obesity-globalization-education/">
    <span class="title">Next »</span>
    <br>
    <span>Obesity, Globalization, and Education: An Empirical Panel Data Analysis</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="https://lun421.github.io/">Gavin&#39;s Website</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
